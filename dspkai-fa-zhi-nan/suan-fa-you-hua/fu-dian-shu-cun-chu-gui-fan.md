# 浮点数存储规范 {#2浮点数存储规范}

## 小数转 2 进制

方法：乘2取整 对十进制小数乘2得到的整数部分和小数部分，整数部分既是相应的二进制数码，再用2乘小数部分\(之前乘后得到新的小数部分\)，又得到整数和小数部分。如此不断重复，直到小数部分为0或达到精度要求为止。第一次所得到为最高位，最后一次得到为最低位。

如0.25的二进制： 0.25\*2 = 0.5 取整是0， 0.5\*2 =1.0 取整是1， 即0.25的二进制为 0.01（第一次所得到为最高位,最后一次得到为最低位）。

0.8125的二进制： 0.8125\*2=1.625 取整是1， 0.625\*2=1.25 取整是1， 0.25\*2=0.5 取整是0， 0.5\*2=1.0 取整是1， 即0.8125的二进制是0.1101（第一次所得到为最高位,最后一次得到为最低位）。

## 浮点数存储规范

浮点数的存储规范，就是由IEEE指定的，具体的规范文件是：IEEE Standard 754 for Binary Floating-Point Arithmetic。读者可以很容易的从网络上下载到这篇文档。

IEEE754规定浮点数由三部分组成：

1. 1-bit 符号位 S，0为正，1为负；
2. Exponent（bias）：指数部分e = E + bias；单精度为 8 bits，双精度为 11 bits；其中bias比较复杂，单精度的 bias 为 127， 双精度的 bias 为 1023。
3. Mantissa（fraction）：尾数部分 f = .b0b1...bp；有效数据的小数部分。 需要注意的是，

4. 单精度格式：

![](/assets/选区_116.png)

就单精度举例说明：10进制的 0.8125，换成二进制是0.1101，相当于$$1.101*2^{-1}$$。S=0; e = -1+127=126=111 1110; f=101。将这三个值代入上图就可以得到0.8125在内存中的值应该是：0x3f500000。

* 双精度格式：

![](/assets/选区_117.png)

